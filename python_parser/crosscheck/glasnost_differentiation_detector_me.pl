# The script assumes 3 runs per test! Older Glasnost tests had only 2 runs.
# Ported from glasnost-analysis2.php

# Input file as generated by generate_summary2.pl

# Test order per user:
	# - 6x upload from the client to the server on an application-specific port, interleaving transfers emulating application traffic and traffic with random bytes
	# - 6x upload from the client to the server on a neutral port, interleaving transfers emulating application traffic and traffic with random bytes
	# - 6x download of the client from the server on an application-specific port, interleaving transfers emulating application traffic and traffic with random bytes
# - 6x download of the client from the server on a neutral port, interleaving transfers emulating application traffic and traffic with random bytes

# Written by Marcel Dischinger, MPI-SWS 2010
# License: CC BY-SA 3.0 (http://creativecommons.org/licenses/by-sa/3.0/)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# HA Dec-2011:  this version has been slightly modified to make it possible to interact with as a subprocess
#
#               input is read from STDIN, output is flushed immediately, error messages are also sent to STDOUT
#  				script-in:  	<<start-time;ip;hostname;client_sum;server_sum;dir;file;>>
#				script-out:		<<ts ip hostname results_upload results_download>> 
#				results are quoted and include information on port block/fail, and protocol and port throttling, or OK
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

use strict;
use warnings;

# use DateTime;
# use Geo::IP;
use POSIX qw(floor);
use Math::Round qw(round);      # if error, install with: sudo cpan install Math::Round


use IO::Handle '_IOFBF';

use constant {
	YES  => 0,
	NO   => 1,
	DONTKNOW => 2,
	NOISE => 2,
	UPLOAD => 0,
	DOWNLOAD => 1,
};

# Thresholds to determine whether there is rate limiting
# See Glasnost NSDI'10 paper
my $noise_thres = 0.2;
my $diff_thres = 0.2;

#my $fsummary = shift;
#my $fsummary = STDIN;

#open IN, $fsummary or die $!;
while(<>){
	chomp;  
	
	my @part = split(';');
	
	my $ts = int($part[0]/1000); # Unix timestamp
	my $ip = $part[1];
	my $hostname = $part[2];
	
	# Client-side data. expu: bytes uploaded, expd: bytes downloaded, expl: test duration, expr: reset received?
	my (@expu, @expd, @expl, @expr);
	# Server-side data. expsu: bytes uploaded, expsd: bytes downloaded, expsl: test duration
	#                   expsr: num resets received, expsrs: num resets sent
	my (@expsu, @expsd, @expsl, @expsr, @expsrs);
	# Test configuration: protocol: application test, repeat: how often to run a measurement, duration: how long to run each measurement
		#                     port1: First server port to run measurement on, port2: second server port to run measurement on (client-side ports are random)
	#                     Ports can change if busy on server side. Ports can also be configured negative to use defaults. Check expp 
	my ($protocol, $repeat, $duration, $port1, $port2);
	
	# Client-side data
	my @arg = split('&', $part[3]);
	foreach(@arg){
		if(/^expprot0=(.+)$/){
			$protocol = $1;
			} elsif(/^expp0=(\d+)$/){ # application-specific port actually used
			$port1 = $1;
			} elsif(/^expp18=(\d+)$/){ # neutral port actually used
			$port2 = $1;
			} elsif(/^expu(\d+)=(\d+)$/){
			$expu[$1] = $2;
			} elsif(/^expd(\d+)=(\d+)$/){
			$expd[$1] = $2;
			} elsif(/^expl(\d+)=([\d\.]+)$/){
			$expl[$1] = $2;
			} elsif(/^expr(\d+)=(\d+)$/){
			$expr[$1] = $2;
			} elsif(/^repeat=(\d+)$/){
			$repeat = $1;
			} elsif(/^duration=(\d+)$/){
			$duration = $1;
		}
	}
	# Server-side data
	my @sarg = split('&', $part[4]);
	foreach(@sarg){
		if(/^expsu(\d+)=(\d+)$/){
			$expsu[$1] = $2;
			} elsif(/^expsd(\d+)=(\d+)$/){
			$expsd[$1] = $2;
			} elsif(/^expsl(\d+)=([\d\.]+)$/){
			$expsl[$1] = $2;
			} elsif(/^expsr(\d+)=(\d+)$/){
			$expsr[$1] = $2;
			} elsif(/^expsrs(\d+)=(\d+)$/){
			$expsrs[$1] = $2;
		}
	}
	
	# Filter
	if(1)
	{
		if($protocol ne "BitTorrent") {
			print "STDERR  $ip $hostname unsupported !$protocol!\n"; #HA
			STDOUT->flush();
			next;
		}
		#    next if($protocol ne "FlashVideo");
	}
	
	# Sanity checks
	if(1)
	{
		# 1. Protocols and ports are known
		if(! defined($protocol)){
			#print STDERR "$ip $hostname No protocol\n";
			print "STDERR $ip $hostname No application port\n";
			STDOUT->flush();			
			next;
		}
		if(! defined($port1)){
			#print STDERR "$ip $hostname No application port\n";
			print "STDERR $ip $hostname No application port\n";
			STDOUT->flush();			
			next;
		}
		if(! defined($port2)){
			#print STDERR "$ip $hostname No control port\n";
			print "STDERR $ip $hostname No control port\n";
			STDOUT->flush();			
			next;
		}
		
		# 2. Got full data from client and server
		my $num_tests = $repeat * 2 *2 * 2;
		if(scalar @expd != $num_tests){
			#printf STDERR "$ip $hostname Only %d of %d test results on client\n", scalar @expd, $num_tests;
			printf "STDERR $ip $hostname Only %d of %d test results on client\n", scalar @expd, $num_tests;
			STDOUT->flush();						
			next;
		}
		
		if(scalar @expsd != $num_tests){
			#printf STDERR "$ip $hostname Only %d (%d) of %d test results on server\n", scalar @expsd, scalar @expsu, $num_tests;
			printf "STDERR $ip $hostname Only %d (%d) of %d test results on server\n", scalar @expsd, scalar @expsu, $num_tests;
			STDOUT->flush();						
			next;
		}
		
		#     
			#     # BUG! Of course it is OK if this is sometimes 0
			#     my $missing_data = 0;
			#     for(my $i=0; $i<$num_tests; $i++){
			#       if(! defined $expsd[$i] || $expsd[$i] == 0){
			# 	$missing_data += 1;
			#       }
			#       elsif(! defined $expd[$i] || $expsd[$i] == 0){
			# 	$missing_data += 1;
			#       }
			#     }
			#     
			#     # TODO OK, this is way to restrictive. If tests are blocked, skip throttling computations!
			#     if($missing_data > 0){
			#       printf STDERR "$ip $hostname %d of %d test results missing on server\n", $missing_data, $num_tests;
			#       next; 
		#     }
		
		# 3. Tests ran long enough
			#     for(my $i=0; $i<scalar @expd; $i++){
			#       if(! defined $expl[$i]){ print STDERR "$ip $hostname expl$i\n";}
			#       if(! defined $expsl[$i]){ print STDERR "$ip $hostname expsl$i\n";}
			#       if(($expl[$i] < ($duration-2)) && ($expsl[$i] < ($duration-2))){
			# 	printf STDERR "$ip $hostname Test %d too short %d %d (%d)\n", $i, $expl[$i], $expsl[$i], $duration;
			# 	next;
			#       }
		#     }
		for(my $i=0; $i<scalar @expd; $i++){
			if(! defined $expl[$i] || !defined $expsl[$i] || ($expl[$i] == 0 && $expsl[$i] == 0))
			{ 
				#print STDERR "$ip $hostname expl$i\n";
				print "STDERR $ip $hostname expl$i\n";
			}
		}
	}
	
	my @dir;
	my $uncertainty = 0;
	if(1)
	{
		# Decide which of the flows are uploads and which are downloads
		# This code is more general than necessary, but will then also work for user-generated tests
		for(my $n=0; $n<2; $n++)
		{
			my $up = 0; 
			my $down = 0;
			for(my $i=0; $i<$repeat*4; $i++)
			{
				if(defined $expd[$n*$repeat*4+$i] && defined $expsd[$n*$repeat*4+$i])
				{
					if($expd[$n*$repeat*4+$i] > $expsd[$n*$repeat*4+$i]) { $down++; }
					elsif($expd[$n*$repeat*4+$i] < $expsd[$n*$repeat*4+$i]) { $up++; }
					else # use default
					{
						if($n == 0){ $up++; }
						else { $down++; }
					}
				}
			}
			
			if($up > $down){ $dir[$n] = UPLOAD; }
			elsif($up < $down){ $dir[$n] = DOWNLOAD; }
			elsif($n == 0){ $dir[$n] = UPLOAD; }
			else { $dir[$n] = DOWNLOAD; }
			
			# There should be the same number of uploads and downloads
			if($up != $down)
			{
				$uncertainty = max($uncertainty, 1/abs($up-$down));
			}
			else
			{
				$uncertainty = 1;
			}
		}
	}
	if(!defined $dir[0] || ($dir[0] == $dir[1]) || ($uncertainty > (1/$repeat))) # Fall back to defaults
	{
		$dir[0] = UPLOAD;
		$dir[1] = DOWNLOAD;
	}
	
	# 0: protocol1 upstream port1
		# 1: protocol2 upstream port1
		# 2: protocol1 upstream port2
		# 3: protocol2 upstream port2
		# 4: protocol1 downstream port1
		# 5: protocol2 downstream port1
		# 6: protocol1 downstream port2
		# 7: protocol2 downstream port2
	# Note that each measurement is run 3 times
	
	# Precomputations: Get noise and max tput for each flow type
	my (@max, @noise, @blocking, @nodata);
	
	my ($base, $port);
	my $failed_sanity_check = 0;
	for(my $n=0; $n<8; $n++)
	{
		if($n == 0) { $base = 0; $port = $port1; }
		elsif($n == 1) { $base = 1; $port = $port1; }
		elsif($n == 2) { $base = 2*$repeat; $port = $port2; }
		elsif($n == 3) { $base = 2*$repeat+1; $port = $port2; }
		elsif($n == 4) { $base = 4*$repeat; $port = $port1; }
		elsif($n == 5) { $base = 4*$repeat+1; $port = $port1; }
		elsif($n == 6) { $base = 6*$repeat; $port = $port2; }
		elsif($n == 7) { $base = 6*$repeat+1; $port = $port2; }
		
		my @bps;
		my $sane = 1;
		my $reset_count = 0;
		my $nodata_count = 0;
		
		
		for(my $i=0; $i<$repeat; $i++)
		{
			if((!defined $expl[$base+$i*2] || !($expl[$base+$i*2] > 0)) &&
			(!defined $expsl[$base+$i*2] || !($expsl[$base+$i*2] > 0)))
			{
				print "STDERR $ip $hostname DEBUG not-sane: n=$n\n"; # HA. apparently never gets here
				$sane = 0;
				$nodata_count ++;
				#last;
			}
		}
		$nodata[$n] = $nodata_count;
		$blocking[$n] = 0;
		
		my $direction;
		if($n < 4){ $direction = $dir[0]; }
		else { $direction = $dir[1]; }
		
		if($sane == 1)
		{
			# Quantify noise and get max
			for(my $i=0; $i<$repeat; $i++)
			{
				if($direction == DOWNLOAD)
				{
					if(defined $expd[$base+$i*2] && ($expd[$base+$i*2] > 0) && ($expl[$base+$i*2] > 0))
					{
						#$bps[@bps] = sprintf("%d", (int)(0.008* $expd[$base+$i*2] / $expl[$base+$i*2]));
						#$bps[@bps] = round(0.008* $expd[$base+$i*2] / $expl[$base+$i*2]);
						$bps[@bps] = (0.008* $expd[$base+$i*2] / $expl[$base+$i*2]);
					}
					else
					{
						$nodata_count++;
					}
				}
				elsif($direction == UPLOAD)
				{
					if(defined $expsd[$base+$i*2] && ($expsd[$base+$i*2] > 0) && ($expsl[$base+$i*2] > 0))
					{
						#$bps[@bps] = sprintf("%d", (int)(0.008* $expsd[$base+$i*2] / $expsl[$base+$i*2]));
						#$bps[@bps] = round(0.008* $expsd[$base+$i*2] / $expsl[$base+$i*2]);
						$bps[@bps] = (0.008* $expsd[$base+$i*2] / $expsl[$base+$i*2]);
					}
					else
					{
						$nodata_count++;
					}
				}
				
				# Checking: If both sides have seen resets and the server did not send any
				if(defined $expsr[$base+$i*2] && defined $expr[$base+$i*2] && ($expr[$base+$i*2] > 0) && ($expsr[$base+$i*2] > 0) && ($expl[$base+$i*2] < $duration)
				&& (! defined $expsrs[$base+$i*2] || ($expsrs[$base+$i*2] == 0)))
				{
					$reset_count++;
				}
			}
			
			$blocking[$n] = $reset_count;
			$nodata[$n] = $nodata_count;
			
			if(scalar @bps > 0)
			{
				@bps = sort{$a <=> $b} @bps;
				
				$max[$n] = $bps[scalar @bps -1];
				if(defined $bps[scalar @bps -1] && ($bps[scalar @bps -1] > 0))
				{
					$noise[$n] = ($bps[scalar @bps -1] - $bps[floor(0.5* scalar @bps)]) / $bps[scalar @bps -1];
				}
				else
				{
					#print STDERR "$ip $hostname Broken bandwidth measurement\n";
					print "STDERR $ip $hostname Broken bandwidth measurement\n";
					STDOUT->flush();
					$failed_sanity_check = 1;
					last;
				}
			}
			else
			{
				# Blocking! No data was transfered at all.
					# ISP could block based on port, based on a single TCP payload packet, or based on server IP (Glasnost blocking)
				# TODO handle this more gracefully
				#print STDERR "$ip $hostname Missing bandwidth measurement\n";
				print "STDERR $ip $hostname Missing bandwidth measurement\n";
				STDOUT->flush();
				$failed_sanity_check = 1;
				last;
			}
		}
	}
	
	if($failed_sanity_check == 1){ next; }
	
	# Results
	####################
	
	print "$ts $ip $hostname";
	
	# 1. Blocking (TCP RST - no data currently unimplemented)
	
	for(my $n=0; $n<8; $n++)
	{
		# Exclude flows that we already reported to be blocked
		if(($n == 0) || ($n == 1) || ($n == 4) || ($n == 5)) {
			$port = $port1;
		}
		if(($n == 2) || ($n == 3) || ($n == 6) || ($n == 7)) {
			$port = $port2;
		}
		
		my $direction;
		if($n < 4){ $direction = "upload"; }
		else { $direction = "download"; }
		my $proto;
		if(($n%2) == 0){ $proto = $protocol; }
		else { $proto = "Control flow"; }
		
		
		if($blocking[$n] > 0)
		{
			print " \"$blocking[$n] $proto $direction port $port blocked\"";
		}
		elsif($nodata[$n] > 0)
		{
			print " \"$nodata[$n] $proto $direction port $port failed\"";
		}
	}
	
	# 2. Differentiating (throttling)
	
	my (@diff_res, @diff_detail);
	for(my $n=0; $n<4; $n++)
	{
		# Start with upstream
		my $direction;
		if(($n%2) == 0){ $direction = "upload"; }
		else { $direction = "download"; }
		
		my $diff = 0;
		my $noisy = 0;
		
		my $max_cf = -1;
		my $max_pr = -1;
		
		if(($n == 0) || ($n == 1)) # Application-based differentiation
		{
			if($n == 0) # Upstream
			{
				if($dir[0] == UPLOAD){ $base = 0; }
				else { $base = 4; }
			}
			elsif($n == 1) # Downstream
			{
				if($dir[0] == DOWNLOAD){ $base = 0; }
				else { $base = 4; }
			}
			
			my $max1 = $max[$base];
			my $max2 = $max[$base+1];
			my $noise1 = $noise[$base];
			my $noise2 = $noise[$base+1];
			
			if(! defined $noise1)
			{ 
				#print STDERR "$ip $hostname $base\n"; 
				print "STDERR $ip $hostname missing $base\n"; 
				exit;
			}
			
			if(($noise1 <= $noise_thres) && ($noise2 <= $noise_thres))
			{
				if((abs($max1 - $max2)/max($max1, $max2)) > $diff_thres)
				{
					$diff_res[$n] = YES;
					$diff_detail[$n][0] = $max2;
					$diff_detail[$n][1] = $max1;
				}
				else
				{
					$diff_res[$n] = NO;
					$diff_detail[$n][0] = $max2;
					$diff_detail[$n][1] = $max1;
				}
			}
			else { $diff_res[$n] = NOISE; }
			
			
			$max1 = $max[$base+2];
			$max2 = $max[$base+3];
			$noise1 = $noise[$base+2];
			$noise2 = $noise[$base+3];
			
			if(! defined $noise1)
			{ 
				#print STDERR "$ip $hostname $base\n"; 
				print "STDERR $ip $hostname missing $base\n"; 
				exit;
			}
			
			if(($noise1 <= $noise_thres) && ($noise2 <= $noise_thres))
			{
				if((abs($max1 - $max2)/max($max1, $max2)) > $diff_thres)
				{
					$diff_res[4+$n] = YES;
					$diff_detail[4+$n][0] = $max2;
					$diff_detail[4+$n][1] = $max1;
				}
				else
				{
					$diff_res[4+$n] = NO;
					$diff_detail[4+$n][0] = $max2;
					$diff_detail[4+$n][1] = $max1;
				}
			}
			else { $diff_res[4+$n] = NOISE; }
		}
		elsif(($n == 2 || $n == 3)) # Port-based differentiation
		{
			if($n == 2) # Upstream
			{
				if($dir[0] == UPLOAD){ $base = 0; }
				else { $base = 4; }
			}
			elsif($n == 3) # Downstream
			{
				if($dir[0] == DOWNLOAD){ $base = 0; }
				else { $base = 4; }
			}
			
			my $max1 = $max[$base];
			my $max2 = $max[$base+2];
			my $noise1 = $noise[$base];
			my $noise2 = $noise[$base+2];
			
			if(($noise1 <= $noise_thres) && ($noise2 <= $noise_thres))
			{
				if((abs($max1 - $max2)/max($max1, $max2)) > $diff_thres)
				{
					my $diff_port;
					if($max1 > $max2) { $diff_port = $port2; }
					else { $diff_port = $port1; }
					
					$diff_res[$n] = YES;
					$diff_detail[$n][0] = $max2;
					$diff_detail[$n][1] = $max1;
					$diff_detail[$n][2] = $diff_port;
				}
				else
				{
					$diff_res[$n] = NO;
					$diff_detail[$n][0] = $max2;
					$diff_detail[$n][1] = $max1;
				}
			}
			else 
			{ 
				$diff_res[$n] = NOISE; 
			}
			
			$max1 = $max[$base+1];
			$max2 = $max[$base+3];
			$noise1 = $noise[$base+1];
			$noise2 = $noise[$base+3];
			
			if(($noise1 <= $noise_thres) && ($noise2 <= $noise_thres))
			{
				if((abs($max1 - $max2)/max($max1, $max2)) > $diff_thres)
				{
					my $diff_port;
					if($max1 > $max2) { $diff_port = $port2; }
					else { $diff_port = $port1; }
			
					$diff_res[4+$n] = YES;
					$diff_detail[4+$n][0] = $max2;
					$diff_detail[4+$n][1] = $max1;
					$diff_detail[4+$n][2] = $diff_port;
				}
				else
				{
					$diff_res[4+$n] = NO;
					$diff_detail[4+$n][0] = $max2;
					$diff_detail[4+$n][1] = $max1;
				}
			}
			else 
			{ 
				$diff_res[4+$n] = NOISE; 
			}
		}
	}
	
	
	# Now output results
	for(my $n=0; $n<2; $n++)
	{
		# Start with upstream
		my $direction;
		if(($n%2) == 0){ $direction = "upload"; }
		else { $direction = "download"; }
		
		# Is there differentiation in the upstream/downstream?
		
		if(($diff_res[$n] == NOISE) || ($diff_res[$n+2] == NOISE) || ($diff_res[$n+4] == NOISE) || ($diff_res[$n+6] == NOISE))
		{
			# $noise_warning;
		}
		
		if(($diff_res[$n] == YES) || ($diff_res[$n+2] == YES) || ($diff_res[$n+4] == YES) || ($diff_res[$n+6] == YES))
		{
			#Rate limit in $direction
			#       print " \"$direction throttled\"";
		}
		elsif(($diff_res[$n] == NOISE) && ($diff_res[$n+2] == NOISE) && ($diff_res[$n+4] == NOISE) && ($diff_res[$n+6] == NOISE))
		{
			#Too noisy
			#print " \"$direction noisy\""; ## COMMENTED HA
		}
		elsif(($diff_res[$n] == NO) && ($diff_res[$n+2] == NO) && ($diff_res[$n+4] == NO) && ($diff_res[$n+6] == NO))
		{
			#No shaping
			#       print " \"$direction OK\"";
		}
		
		else
		{
			# No shaping but partially too noisy
		}
		
		
		# (b) App-based?
		if(($diff_res[$n] == NOISE) && ($diff_res[4+$n] == NOISE)) # Noise is too high
		{
			#       print "The measurement data is too noisy to detect whether your
			#       ISP rate limits your $protocol ${direction}s.";
			print " \"$direction $protocol noisy\""; ## ADDED HA
		}
		else
		{
			my ($max_cf, $max_pr);
			if(($diff_res[$n] == YES) || ($diff_res[4+$n] == YES)) # Differentiation!
			{
				if($diff_res[$n] == YES)
				{
					$max_cf = $diff_detail[$n][0];
					$max_pr = $diff_detail[$n][1];
				}
				if($diff_res[4+$n] == YES)
				{
					$max_cf = $diff_detail[4+$n][0];
					$max_pr = $diff_detail[4+$n][1];
				}
				
				print " \"$direction $protocol throttled\"";
				# 	print "Your ISP appears to rate limit your $protocol
					# 	${direction}s.</span>
					# 	In our tests, ${direction}s using control flows achieved up to
				# 	$max_cf Kbps while ${direction}s using $protocol achieved up to $max_pr Kbps.</p>\n";
			}
			else # No differentiation!
			{
				if($diff_res[$n] == NO)
				{
					$max_cf = $diff_detail[$n][0];
					$max_pr = $diff_detail[$n][1];
				}
				if($diff_res[4+$n] == NO)
				{
					$max_cf = $diff_detail[4+$n][0];
					$max_pr = $diff_detail[4+$n][1];
				}
				
				print " \"$direction $protocol OK\"";
				# 	print "There is no indication that your ISP rate limits 
					# 	your $protocol ${direction}s.
					# 	In our tests, ${direction}s using control flows achieved up to 
				# 	$max_cf Kbps while ${direction}s using $protocol achieved up to $max_pr Kbps.";
			}
		}
		
		# (c) Port-based?
		if(($diff_res[2+$n] == NOISE) && ($diff_res[6+$n] == NOISE)) # Noise is too high
		{
			#       print "The measurement data is too noisy to detect whether your
			#       ISP rate limits traffic on port $port1";
			print " \"$direction port noisy\""; ## ADDED HA
		}
		else
		{
			my ($max_cf, $max_pr, $diff_port);
			if(($diff_res[2+$n] == YES) || ($diff_res[6+$n] == YES)) # Differentiation!
			{
				if($diff_res[2+$n] == YES)
				{
					$max_cf = $diff_detail[2+$n][0];
					$max_pr = $diff_detail[2+$n][1];
					$diff_port = $diff_detail[2+$n][2];
				}
				if($diff_res[6+$n] == YES)
				{
					$max_cf = $diff_detail[6+$n][0];
					$max_pr = $diff_detail[6+$n][1];
					$diff_port = $diff_detail[6+$n][2];
				}
				
				print " \"$direction port throttled\"";	
				# 	print "Your ISP appears to rate limit ${direction}s on port 
					# 	$diff_port.
					# 	In our tests, ${direction}s on port $port1 achieved up to $max_cf Kbps
				# 	while ${direction}s on port $port2 achieved up to $max_pr Kbps.";	
			}
			else{
				# No differentiation!
				print " \"$direction port OK\"";
			}
		}
	}
	
	print "\n";
	STDOUT->flush();
}








sub max{
	if($_[0] >= $_[1]){ return $_[0]; }
	else{ return $_[1]; }
}
